/*
 (C) Copyright 2015, TP-Link Inc, konstantin.mauch@tp-link.com

 This program is free software; you can redistribute it and/or
 modify it under the terms of the GNU General Public License as
 published by the Free Software Foundation; either version 2 of
 the License, or (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT any WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program; if not, write to the Free Software
 Foundation, Inc., 59 Temple Place, Suite 330, Boston,
 MA 02111-1307 USA
*/

#include <string.h>
#include <getopt.h>

#include <curl/curl.h>

#include <libxml/parser.h>
#include <libxml/tree.h>


#include "verbose.h"
#include "opcodes.h"
#include "constants.h"
#include "lists.h"
#include "xmls.h"
#include "auxiliary.h"


/* Index of desired operation (can be 'create', 'save', 'ACL', 'firmware' )*/
int iOperation;//TODO : we keep it here as long as iOpenSite() is called prior to everythiong.
//TODO: we'll remove it from here as soon as we remove iOpenSite();

/* Intermediate URL structure */
CURL *curl;


int input_pipe[2];//TODO: del

/* Payload of POST method during user authenticate. Initializaed in <process_http_target>. */
char * cPostMethodString;

/* Extra payload of POST method during user authenticate. Initializaed in <process_http_target>. */
char * cPostMethodString2;


char cArg0[MAX_URL_SIZE];

/* pointers onto cPostMethodString, cPostMethodString2 */
char ** pcPtr2Extra1, **pcPtr2Extra2;

/* Extra payload should be attached  */
int iExtra;


/* Ptr to XML data for in memory */
xmlNode *root_element = NULL;

/* Ptr to XML data document */
xmlDoc *doc = NULL;

/* Max path. TODO: it's incorrect assume max command line length id equal to max path length */
#define M_PATH	260

/* Single command buffer */
char cCmdDataBuf[M_PATH];// TODO: 2 DEL

/* Data structure type definition */
#include "../ssh/cmds.h"


typedef struct _tf {
	char * pcName;
	int iOp;
	int iAmt;
	char * pcVar;
} tf;

tf tfOpTable[] =
{
	/* Singletons: operation names */
	{"open\n", DO_OPEN_OP, 1, NULL},
	{"close\n", DO_CLOSE_OP, 1, NULL},
	{"ACL\n", DO_ACL_OP, 1, NULL},
	{"upgrade\n", DO_FIRMWARE_OP, 1, NULL},
	{"reboot\n", DO_REBOOT_OP, 1, NULL},
	{"ipassign\n", DO_IPSET_OP, 1, NULL},

	{"ipV6assign\n", DO_IPV6SET_OP, 1, NULL},
	{"acontrol\n", DO_ACNTL_OP, 1, NULL},
	{"psecure\n", DO_PSEC_OP, 1, NULL},
	{"pmirror\n", DO_PMIR_OP, 1, NULL},
	{"vlancrt\n", DO_VLANCR_OP, 1, NULL},
	{"iprange\n", DO_IPRAN_OP, 1, NULL},
	{"pfilter\n", DO_PFILT_OP, 1, NULL},
	{"ping\n", DO_PING_OP, 1, NULL},
	{"tracert\n", DO_TRACERT_OP, 1, NULL},
	{"cable\n", DO_CABLE_OP, 1, NULL},
	{"looback\n", DO_LOOPBK_OP, 1, NULL},

	/* Couples: names of variables and their values */
	{"target", DO_NO_OP,	2, cIpAddr},
	{"id", DO_NO_OP,	2, _tid_},
	{"community", DO_NO_OP, 2, txt_comname},
	{"filename", DO_NO_OP,	3, cFwName},
	{"acl-data", DO_NO_OP,	2, aclId},
	{"ip-addr", DO_NO_OP,	2, ip_address},
	{"ip-mask", DO_NO_OP,	2, ip_mask},
	{"xml-data", DO_NO_OP,	2, cXmlName},

	{"t_mode", DO_NO_OP,	2, t_mode},
	{"t_key", DO_NO_OP,	2, t_key},
	{"t_stat", DO_NO_OP,	2, t_stat},
	{"chk_", DO_NO_OP,	2, chk_},
	{"cb_", DO_NO_OP,	2, cb_},
	{"list_", DO_NO_OP,	2, list_},
	{"member_", DO_NO_OP,	2, member_},
	{"proof", DO_NO_OP,	2, proof},
	{NULL, 0, 0, NULL}
};



/* Pointer to a dynamic structure to store command tray */
pCmdType pHttpCmdChain;


char Arg0[260];//TODO: ..
int iParseCmdArgs(char ** argv, int argc)
{
int iOption;

	/* Assign program name, requirted for output*/
	strcpy (Arg0, argv[0]);

	/* Index of the option */
	int iOptIndex = 0;

	/* Assuming <tfOpTable [iOptIndex]> is not null. We can assume it. */
	while ( NULL != tfOpTable [iOptIndex].pcName )
	{
		iOperation = -1;

		/* Singletons */
		if (1 == tfOpTable [iOptIndex].iAmt) 
		{
			if ( 0 == strcmp(tfOpTable[iOptIndex].pcName, argv[0]) )
			{
				printf("<%s> found. BREAK.\n", tfOpTable[iOptIndex].pcName);
				iOperation= tfOpTable[iOptIndex].iOp;
				break;
			}

		}
		/* Couples */
		else
			if (2 == tfOpTable [iOptIndex].iAmt)
			{
				if ( 0 == strcmp(tfOpTable[iOptIndex].pcVar, argv[0]) )
				{
					printf("<%s> found. BREAK.\n", tfOpTable[iOptIndex].pcVar);
					strcpy(tfOpTable[iOptIndex].pcVar, optarg);
					break;
				}
			}

		iOptIndex++;

	} /* while () */
	



	/* Ensure that file <cast.XXXXX.txt.xml>. Generated by <make_xml.sh> */
	if ( NULL == cXmlName )
	{
		HCOMMON("%s: ERROR: name of XML file to parse should be passed on command line\n", cArg0);

		return -9;//TODO: rem.
	}

	/* To this moment <voc.c> and <voc.h> are nearby, otherwise <autogen.cmd+make> was failed */
	if (INJ_SUCCESS != XmlAuxCreateEx() ) 
	{
		HCOMMON("%s: ERROR: no rules to handle (%s) learned\n", cArg0, cXmlName);

		return -9;//TODO: rem.
	}

	/* Check potential ABI mismatches between the version it was compiled for and the actual shared library used */
	LIBXML_TEST_VERSION 	// TODO: may we skip it ?


	char pcCastFile[M_PATH];

	/* Get the contents of <cast.XXXXX.txt.xml> into <doc> */
	strcpy(pcCastFile, "./cast.5428E.xml");//TODO: remove hardcoded stuff
	doc = xmlReadFile(pcCastFile, NULL, 0);//TODO: put if-else construction here


	if (NULL == doc)
	{
		HCOMMON("%s: ERROR: could not parse file %s\n", cArg0, pcCastFile);

		return -9;//TODO: rem.
	}

	/* Get the root node of the XML data stored in the <doc> */
	root_element = xmlDocGetRootElement(doc);//TODO: put if-else construction here




#if (1)

	/* At this time point we assume all parameters parsed OK, so let's call inj. primitives */
	switch (iOperation)
	{
		case DO_OPEN_OP:
			VERBOSE_STATUS(iOpenSite)
			break;

		case DO_CLOSE_OP:
			VERBOSE_STATUS(iCloseSite)
			break;

		case DO_CREATE_OP:
			VERBOSE_STATUS(iCreateSnmp)
			break;

		case DO_SAVE_OP:
			VERBOSE_STATUS(iSaveSite)
			break;

		case DO_ACL_OP:
			VERBOSE_STATUS(iAclGroup)
			break;

		case DO_FIRMWARE_OP:
			VERBOSE_STATUS(iUpgradeFirmware)
			break;

		case DO_REBOOT_OP:
			VERBOSE_STATUS(iRebootSwitch)
			break;

		case DO_IPSET_OP:
			VERBOSE_STATUS(iAssignIp)
			break;

		/* TODO: this is a stub only; no real implementation */
		case DO_IPV6SET_OP:
			VERBOSE_STATUS2(iMeta2, "idle1", "idle2")
			break;

		/* TODO: these are stubs only; no real implementation */
		case DO_ACNTL_OP:
		case DO_PSEC_OP:
		case DO_PMIR_OP:
		case DO_VLANCR_OP:
		case DO_VLANC_OP:
		case DO_IPRAN_OP:
		case DO_PFILT_OP:
		case DO_PING_OP:
		case DO_TRACERT_OP:
		case DO_CABLE_OP:
		case DO_LOOPBK_OP:
			VERBOSE_STATUS1(iMeta1, "idle")
			break;

		case DO_NO_OP:
		default:
			printf("%s: there's no operation with OPCODE=%d, exiting\n", cArg0, iOperation);
			break;
		
	}


#endif /* (0) */

	/* Delete entire list with URLs along with its compounds */
	DeleteUrlEx(&pUrlChain);




	/* Delete vocabuilary, et al*/
	DeleteXmlAuxEx(&pAuxiliary);

	/* Free the document */
	xmlFreeDoc(doc);

	/* Free the global variables that may have been allocated by the parser */
	xmlCleanupParser();





}





static int process_datafile(char * pcFilename)
{
FILE* fp = NULL;

	if(NULL == pcFilename)
	{
		printf("ERROR: assign_host_file - empty filename\n");
		return (-8);//TODO;
	}

	/* Try to open file with commands  */
	if ( NULL == (fp = fopen (pcFilename, "r") ) )
	{
		printf("[%s] %s: can't open file <%s> \n", __FILE__, __func__ , pcFilename);

		return (-9);//TODO;
	}

	/* For each string of Raw Data file */
	while ( ! (feof (fp) ) ) 
	{
		/* Scan whole string into temp. buffer */
		if (NULL == fgets (cCmdDataBuf, M_PATH, fp) )
		{
			/* no string read from data file */
		}
		else
		{
			printf("[%s] %s: scanned:%s", __FILE__, __func__, cCmdDataBuf);

			/* Attach just scanned data */
			EnrollCmd(&pHttpCmdChain, cCmdDataBuf);
		}
	}


	/* Close file, and dispose pointer to Raw Data file */
	fclose(fp);

	return 0;
}


int m_Tocken;

static int m_TockenFound;

static void dump(const char *text, FILE *stream, unsigned char *ptr, size_t size)
{
size_t i;
size_t c;
unsigned int width=0x10;

//TODO: explaine such a choice 
char cBuf[512];

char * cpTockenPtr;
char * cp1, * cp2;

//printf(ptr);
//return 0;

	fprintf(stream, "%s, %10.10ld bytes (0x%8.8lx)\n", text, (long)size, (long)size);

	if ( NULL != ( cpTockenPtr = strstr(ptr, "var g_tid =") ) )
	{
		cp1 = strtok(cpTockenPtr, "\'");
		cp2 = strtok(NULL, "\'");
		m_TockenFound = 1;

		printf("[%s] iTocken = <%s> SUCCESS. TERMINATING. <m_TockenFound=%d>\n", cpTockenPtr, cp2, m_TockenFound);
	}


return;

	for(i=0; i<size; i+= width)
	{
		fprintf(stream, "%4.4lx: ", (long)i);
		/* show hex to the left */

		for(c = 0; c < width; c++)
		{
			if(i+c < size)

				fprintf(stream, "%02x ", ptr[i+c]);
			else
				fputs(" ", stream);
		}

		/* show data on the right */
		for(c = 0; (c < width) && (i+c < size); c++)
			fputc((ptr[i+c]>=0x20) && (ptr[i+c]<0x80)?ptr[i+c]:'.', stream);

		fputc('\n', stream); /* newline */
	}
}


static int m_trace(CURL *handle, curl_infotype type, char *data, size_t size, void *userp)
{
const char *text;
(void)handle;

	switch (type)
	{
		case CURLINFO_TEXT:
		//fprintf(stderr, "== Info: %s", data);
		fprintf(stdout, "== Info: %s", data);
		default: /* in case a new one is introduced to shock us */
		return 0;

		case CURLINFO_HEADER_OUT:
		text = "=> Send header";
		break;

		case CURLINFO_DATA_OUT:
		text = "=> Send data";
		break;

		case CURLINFO_SSL_DATA_OUT:
		text = "=> Send SSL data";
		break;

		case CURLINFO_HEADER_IN:
		text = "<= Recv header";
		break;

		case CURLINFO_DATA_IN:
		text = "<= Recv data";
		break;

		case CURLINFO_SSL_DATA_IN:
		text = "<= Recv SSL data";
		break;
	}

	dump(text, stdout, (unsigned char *)data, size);
	return 0;
} /* int my_trace */


typedef struct _RespStruct
{
	char * cpResponce;

	size_t iSize;

} RespStruct, *pRespStruct;

/* Suppose 32K is enough to include _any HTML responce frmo _this LTE-modem */
char cBuffer[0x400*32];

/* Callback to execute on arrival of HTML responce */
static size_t RecvClbk(void *contents, size_t size, size_t nmemb, void *userp)
{
size_t realsize = size * nmemb;

	RespStruct * HtmlRespStruct = (RespStruct *)userp;

	HtmlRespStruct->cpResponce = (char*)(cBuffer);

	memcpy(HtmlRespStruct->cpResponce, contents, realsize);

	HtmlRespStruct->cpResponce[realsize] = 0;

	HtmlRespStruct->iSize = realsize;

	return realsize;

} /* size_t RecvClbk */


/* Not implemented by now */
int process_http_target(char * pcAddress, char * pcLogin, char * pcPasswd, char * pcDataFile)
{
int iRes;
RespStruct RespStr;
char pcCastFile[M_PATH];


	/* Payload of POST method during user authenticate. */
	cPostMethodString = (char *) malloc (MAX_URL_SIZE);

	/* Extra payload of POST method during user authenticate. */
	cPostMethodString2 = (char *) malloc (MAX_URL_SIZE);


	sprintf(cPostMethodString, "username=%s&password=%s&logon=Login", pcLogin, pcPasswd);

	sprintf(cPostMethodString2,"user=%s&level=1&userID=0", pcLogin);

	strcpy(cIpAddr, pcAddress);//TODO: rework ?

	/* TODO: Maybe to use <cPostMethodString, ..> in lists.c::_DeployUrlEx directly ? */
	pcPtr2Extra1 = (char**)&cPostMethodString;
	pcPtr2Extra2 = (char**)&cPostMethodString2;

printf(">>>> check here result of parsing <%s> \n", pcDataFile);
	/* Fulfill records in <pHttpCmdChain> list */
	process_datafile(pcDataFile);//TODO: put if-else construction here
printf(">>>> end of check of parsing <%s> \n", pcDataFile);




	if(NULL == ( curl = curl_easy_init() ) )
	{
		printf("Can't initialize lib c-url \nERROR\n");// TODO: repl.

		return (-8);// TODO: repl.
	}

	if(curl)
	{
		iRes = curl_easy_setopt(curl, CURLOPT_DEBUGFUNCTION, m_trace);

		/* the DEBUGFUNCTION has no effect until we enable VERBOSE */
		iRes = curl_easy_setopt(curl, CURLOPT_VERBOSE, 1L);

		/* we tell libcurl to follow redirection */
		iRes = curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);

		curl_easy_setopt(curl, CURLOPT_ACCEPT_ENCODING, "gzip, deflate");

		curl_easy_setopt(curl, CURLOPT_VERBOSE, 1L);
		//-10..curl_easy_setopt(curl, CURLOPT_COOKIEFILE, "");

		/* send all data to this function */
		curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, RecvClbk);
		/* we pass our 'RespStr' struct to the callback function */

		curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void *)&RespStr);
		//-10..curl_easy_setopt(curl, CURLOPT_USERAGENT, "libcurl-agent/1.0");

		/* Clean the buffer before receiving a responce into it */
		memset (&RespStr, sizeof (struct _RespStruct) , 0);
		

		//. nah . VERBOSE_STATUS(iOpenSite)
//+++++++++++++++
printf(">>>> now we deploy it \n");
	_ProcessHttpCmds("caller is <process_http_target>", pHttpCmdChain);
printf(">>>> deployed \n");
//+++++++++++++++

		/* Close URL lib */
		curl_easy_cleanup(curl);

	}



	free(cPostMethodString);

	free(cPostMethodString2);


 	return 0;//TODO: repl.
}


